# overal structure of vid file:
# [1-15 bytes - Header] [16 - EOF - Main data]

# types of block:
# 0x01 - video, compression 1
# 0x02 - Pallete (палитра)
# 0x03 - video, compression 2
# 0x04 - video, compression 3
# 0x14 - EOF
# 0x7C - audio, start frame
# 0x7D - audio

# structure of header:
# [1-3 bytes - ASCII "VID"] [4-5 - unknown 0x00 02] [6-7 - number of frames] [8-9 - Widht] [10-11 Height] [12-13 - глобальное базовое значение задержки] [14-15 - всегда 0E00]

# structure of palette:
# [1 byte - block type] [2-769 - 256 VGA palette, Each palette entry is composed of 3 triplets (R/G/B) ranging in value from 0 to 63]

# structure of audio:
# первый блок - 0x7C, остальные - 0x7D
# 0x7C:
# [1 - block type] [2-3 - unknown] [4 - Sound Blaster init-значение, 0xA6] [5-6 - длина аудио-блока (зачем?)] [7-??? - 8 bit audio]
# init-значение соотносится с sample rate (герцовка) как:
# InitVal = 256 - (1000000 DIV SampleRate) (чего блять?)
# SampleRate = 1000000 / (256 - InitVal)
# 0x7D:
# [1 - block type] [2 -3 длина аудио-блока] [4-??? - 8 bit audio]

# structure of video block:
# basic: [1 - block type] [2-3 - время отображения (количество измеряемое в 1/60 секунды)] [4 -??? - сжатое видео]
# в одном блоке видео может быть только один фрейм! конец видео - когда скопировано ширинаXвысота фрейма байтов
# только тип 0x03 содержит полный несжатый фрейм, типы 0x01 и 0x04 - содержат только пиксели, которые изменились с прошлого фрейма

# алгоритм сжатия для 0x01:
# InputByte = читаем байт, собственно
# если InputByte >= 0x80:
#    SkipPixels = InputByte - 0x80 (пропускаем столько пикселей, читем из того, что было в прошлом фрейме)
# если InputByte == 0
#    это конец фрейма
# если InputByte < 0x80:
#    показать байт на экране

# алгоритм для сжатия 0x03:
# InputByte = читаем байт, собственно
# если InputByte >= 0x80:
#    Число_байт = InputByte - 0x80
#    сразу добавить Число_байт из файла в виде--фрейм
# если InputByte == 0:
#    такого быть не должно, exception
# если InputByte < 0x80:
#    занести его в список

# алгоритм для сжатия 0x04
# в структуре так же содержит дополнительно объявление начала строки, откуда начинать [4-5]
# очевидно, если меняется например только нижняя половина кадра - менять только её
# в остальном то же самое, что в 0x01

# structure of EOF:
# [1] всегда 0x14

# стоит обратить внимание на header[12-13] и video[2-3] - эти значения задержек проходят через нижеприведенную формулу
# для вычисления времени проигрывания аудио. Для вычисления времени показа кадра значения просто складываются
# audio_block_size = (header_delay + frame_delay) * 185


# Знания, полученные реверс-инжинирингом:
# Аудиодорожка, получаемая в wav-файле получается сложением всех байтов аудиодорожки в vid-файле.
# Судя по всему там нет никакого сжатия, но протокол wav и заголовок файла все равно нужно разобрать

# саудиодорожкой не все так просто, даже на одиночный фрейм ffplay ругается.
